/* Generated by Opal 0.10.0.dev */
Opal.modules["promise"] = function(Opal) {
  Opal.dynamic_require_severity = "warning";
  var OPAL_CONFIG = { method_missing: true, arity_check: false, freezing: true, tainting: true };
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$resolve', '$new', '$reject', '$attr_reader', '$===', '$value', '$has_key?', '$keys', '$!', '$==', '$<<', '$>>', '$exception?', '$[]', '$resolved?', '$rejected?', '$error', '$include?', '$action', '$realized?', '$raise', '$^', '$call', '$resolve!', '$exception!', '$any?', '$each', '$reject!', '$there_can_be_only_one!', '$then', '$to_proc', '$fail', '$always', '$trace', '$class', '$object_id', '$+', '$inspect', '$act?', '$nil?', '$prev', '$push', '$concat', '$it', '$lambda', '$reverse', '$pop', '$<=', '$length', '$shift', '$-', '$wait', '$map', '$reduce', '$try', '$tap', '$all?', '$find']);
  return (function($base, $super) {
    function $Promise(){};
    var self = $Promise = $klass($base, $super, 'Promise', $Promise);

    var def = self.$$proto, $scope = self.$$scope, TMP_3, TMP_4, TMP_5, TMP_6, TMP_7, TMP_8, TMP_9, TMP_10;

    def.value = def.action = def.exception = def.realized = def.next = def.delayed = def.error = def.prev = nil;
    Opal.defs(self, '$value', function value(value) {
      var self = this;

      return self.$new().$resolve(value);
    });

    Opal.defs(self, '$error', function error(value) {
      var self = this;

      return self.$new().$reject(value);
    });

    Opal.defs(self, '$when', function when() {
      var self = this, $rest_idx, $rest_len = arguments.length - 0;

      var promises = new Array($rest_len > 0 ? $rest_len : 0);
      if ($rest_len > 0) {
        for ($rest_idx = 0; $rest_idx < $rest_len; $rest_idx++) {
          promises[$rest_idx] = arguments[$rest_idx + 0];
        }
      }
      return $scope.get('When').$new(promises);
    });

    self.$attr_reader("error", "prev", "next");

    Opal.defn(self, '$initialize', function initialize(action) {
      var self = this;

      if (action == null) {
        action = $hash2([], {})
      }
      self.action = action;
      self.realized = false;
      self.exception = false;
      self.value = nil;
      self.error = nil;
      self.delayed = false;
      self.prev = nil;
      return self.next = [];
    });

    Opal.defn(self, '$value', function value() {
      var $a, self = this;

      if ((($a = $scope.get('Promise')['$==='](self.value)) !== nil && (!$a.$$is_boolean || $a == true))) {
        return self.value.$value()
        } else {
        return self.value
      };
    });

    Opal.defn(self, '$act?', function () {
      var $a, self = this;

      return ((($a = self.action['$has_key?']("success")) !== false && $a !== nil) ? $a : self.action['$has_key?']("always"));
    });

    Opal.defn(self, '$action', function action() {
      var self = this;

      return self.action.$keys();
    });

    Opal.defn(self, '$exception?', function () {
      var self = this;

      return self.exception;
    });

    Opal.defn(self, '$realized?', function () {
      var self = this;

      return self.realized['$!']()['$!']();
    });

    Opal.defn(self, '$resolved?', function () {
      var self = this;

      return self.realized['$==']("resolve");
    });

    Opal.defn(self, '$rejected?', function () {
      var self = this;

      return self.realized['$==']("reject");
    });

    Opal.defn(self, '$^', function (promise) {
      var self = this;

      promise['$<<'](self);
      self['$>>'](promise);
      return promise;
    });

    Opal.defn(self, '$<<', function (promise) {
      var self = this;

      self.prev = promise;
      return self;
    });

    Opal.defn(self, '$>>', function (promise) {
      var $a, $b, $c, self = this;

      self.next['$<<'](promise);
      if ((($a = self['$exception?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        promise.$reject(self.delayed['$[]'](0))
      } else if ((($a = self['$resolved?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        promise.$resolve((function() {if ((($a = self.delayed) !== nil && (!$a.$$is_boolean || $a == true))) {
          return self.delayed['$[]'](0)
          } else {
          return self.$value()
        }; return nil; })())
      } else if ((($a = self['$rejected?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        if ((($a = ((($b = self.action['$has_key?']("failure")['$!']()) !== false && $b !== nil) ? $b : $scope.get('Promise')['$==='](((function() {if ((($c = self.delayed) !== nil && (!$c.$$is_boolean || $c == true))) {
          return self.delayed['$[]'](0)
          } else {
          return self.error
        }; return nil; })())))) !== nil && (!$a.$$is_boolean || $a == true))) {
          promise.$reject((function() {if ((($a = self.delayed) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.delayed['$[]'](0)
            } else {
            return self.$error()
          }; return nil; })())
        } else if ((($a = promise.$action()['$include?']("always")) !== nil && (!$a.$$is_boolean || $a == true))) {
          promise.$reject((function() {if ((($a = self.delayed) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.delayed['$[]'](0)
            } else {
            return self.$error()
          }; return nil; })())}};
      return self;
    });

    Opal.defn(self, '$resolve', function resolve(value) {
      var $a, $b, self = this, block = nil, e = nil;

      if (value == null) {
        value = nil
      }
      if ((($a = self['$realized?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.$raise($scope.get('ArgumentError'), "the promise has already been realized")};
      if ((($a = $scope.get('Promise')['$==='](value)) !== nil && (!$a.$$is_boolean || $a == true))) {
        return (value['$<<'](self.prev))['$^'](self)};
      try {
        if ((($a = block = ((($b = self.action['$[]']("success")) !== false && $b !== nil) ? $b : self.action['$[]']("always"))) !== nil && (!$a.$$is_boolean || $a == true))) {
          value = block.$call(value)};
        self['$resolve!'](value);
      } catch ($err) {
        if (Opal.rescue($err, [$scope.get('Exception')])) {e = $err;
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };
      return self;
    });

    Opal.defn(self, '$resolve!', function (value) {
      var $a, $b, TMP_1, self = this;

      self.realized = "resolve";
      self.value = value;
      if ((($a = self.next['$any?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        return ($a = ($b = self.next).$each, $a.$$p = (TMP_1 = function(p){var self = TMP_1.$$s || this;
if (p == null) p = nil;
        return p.$resolve(value)}, TMP_1.$$s = self, TMP_1), $a).call($b)
        } else {
        return self.delayed = [value]
      };
    });

    Opal.defn(self, '$reject', function reject(value) {
      var $a, $b, self = this, block = nil, e = nil;

      if (value == null) {
        value = nil
      }
      if ((($a = self['$realized?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.$raise($scope.get('ArgumentError'), "the promise has already been realized")};
      if ((($a = $scope.get('Promise')['$==='](value)) !== nil && (!$a.$$is_boolean || $a == true))) {
        return (value['$<<'](self.prev))['$^'](self)};
      try {
        if ((($a = block = ((($b = self.action['$[]']("failure")) !== false && $b !== nil) ? $b : self.action['$[]']("always"))) !== nil && (!$a.$$is_boolean || $a == true))) {
          value = block.$call(value)};
        if ((($a = self.action['$has_key?']("always")) !== nil && (!$a.$$is_boolean || $a == true))) {
          self['$resolve!'](value)
          } else {
          self['$reject!'](value)
        };
      } catch ($err) {
        if (Opal.rescue($err, [$scope.get('Exception')])) {e = $err;
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };
      return self;
    });

    Opal.defn(self, '$reject!', function (value) {
      var $a, $b, TMP_2, self = this;

      self.realized = "reject";
      self.error = value;
      if ((($a = self.next['$any?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        return ($a = ($b = self.next).$each, $a.$$p = (TMP_2 = function(p){var self = TMP_2.$$s || this;
if (p == null) p = nil;
        return p.$reject(value)}, TMP_2.$$s = self, TMP_2), $a).call($b)
        } else {
        return self.delayed = [value]
      };
    });

    Opal.defn(self, '$exception!', function (error) {
      var self = this;

      self.exception = true;
      return self['$reject!'](error);
    });

    Opal.defn(self, '$then', TMP_3 = function then() {
      var self = this, $iter = TMP_3.$$p, block = $iter || nil;

      TMP_3.$$p = null;
      return self['$^']($scope.get('Promise').$new($hash2(["success"], {"success": block})));
    });

    Opal.defn(self, '$then!', TMP_4 = function () {
      var $a, $b, self = this, $iter = TMP_4.$$p, block = $iter || nil;

      TMP_4.$$p = null;
      self['$there_can_be_only_one!']();
      return ($a = ($b = self).$then, $a.$$p = block.$to_proc(), $a).call($b);
    });

    Opal.alias(self, 'do', 'then');

    Opal.alias(self, 'do!', 'then!');

    Opal.defn(self, '$fail', TMP_5 = function fail() {
      var self = this, $iter = TMP_5.$$p, block = $iter || nil;

      TMP_5.$$p = null;
      return self['$^']($scope.get('Promise').$new($hash2(["failure"], {"failure": block})));
    });

    Opal.defn(self, '$fail!', TMP_6 = function () {
      var $a, $b, self = this, $iter = TMP_6.$$p, block = $iter || nil;

      TMP_6.$$p = null;
      self['$there_can_be_only_one!']();
      return ($a = ($b = self).$fail, $a.$$p = block.$to_proc(), $a).call($b);
    });

    Opal.alias(self, 'rescue', 'fail');

    Opal.alias(self, 'catch', 'fail');

    Opal.alias(self, 'rescue!', 'fail!');

    Opal.alias(self, 'catch!', 'fail!');

    Opal.defn(self, '$always', TMP_7 = function always() {
      var self = this, $iter = TMP_7.$$p, block = $iter || nil;

      TMP_7.$$p = null;
      return self['$^']($scope.get('Promise').$new($hash2(["always"], {"always": block})));
    });

    Opal.defn(self, '$always!', TMP_8 = function () {
      var $a, $b, self = this, $iter = TMP_8.$$p, block = $iter || nil;

      TMP_8.$$p = null;
      self['$there_can_be_only_one!']();
      return ($a = ($b = self).$always, $a.$$p = block.$to_proc(), $a).call($b);
    });

    Opal.alias(self, 'finally', 'always');

    Opal.alias(self, 'ensure', 'always');

    Opal.alias(self, 'finally!', 'always!');

    Opal.alias(self, 'ensure!', 'always!');

    Opal.defn(self, '$trace', TMP_9 = function trace(depth) {
      var self = this, $iter = TMP_9.$$p, block = $iter || nil;

      if (depth == null) {
        depth = nil
      }
      TMP_9.$$p = null;
      return self['$^']($scope.get('Trace').$new(depth, block));
    });

    Opal.defn(self, '$trace!', TMP_10 = function () {
      var $a, $b, self = this, $rest_idx, $rest_len = arguments.length - 0, $iter = TMP_10.$$p, block = $iter || nil;

      var args = new Array($rest_len > 0 ? $rest_len : 0);
      if ($rest_len > 0) {
        for ($rest_idx = 0; $rest_idx < $rest_len; $rest_idx++) {
          args[$rest_idx] = arguments[$rest_idx + 0];
        }
      }
      TMP_10.$$p = null;
      self['$there_can_be_only_one!']();
      return ($a = ($b = self).$trace, $a.$$p = block.$to_proc(), $a).apply($b, Opal.to_a(args));
    });

    Opal.defn(self, '$there_can_be_only_one!', function () {
      var $a, self = this;

      if ((($a = self.next['$any?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        return self.$raise($scope.get('ArgumentError'), "a promise has already been chained")
        } else {
        return nil
      };
    });

    Opal.defn(self, '$inspect', function inspect() {
      var $a, self = this, result = nil;

      result = "#<" + (self.$class()) + "(" + (self.$object_id()) + ")";
      if ((($a = self.next['$any?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        result = $rb_plus(result, " >> " + (self.next.$inspect()))};
      if ((($a = self['$realized?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        result = $rb_plus(result, ": " + ((((($a = self.value) !== false && $a !== nil) ? $a : self.error)).$inspect()) + ">")
        } else {
        result = $rb_plus(result, ">")
      };
      return result;
    });

    (function($base, $super) {
      function $Trace(){};
      var self = $Trace = $klass($base, $super, 'Trace', $Trace);

      var def = self.$$proto, $scope = self.$$scope, TMP_12;

      Opal.defs(self, '$it', function it(promise) {
        var $a, $b, self = this, current = nil, prev = nil;

        current = [];
        if ((($a = ((($b = promise['$act?']()) !== false && $b !== nil) ? $b : promise.$prev()['$nil?']())) !== nil && (!$a.$$is_boolean || $a == true))) {
          current.$push(promise.$value())};
        if ((($a = prev = promise.$prev()) !== nil && (!$a.$$is_boolean || $a == true))) {
          return current.$concat(self.$it(prev))
          } else {
          return current
        };
      });

      return (Opal.defn(self, '$initialize', TMP_12 = function initialize(depth, block) {
        var $a, $b, TMP_11, self = this, $iter = TMP_12.$$p, $yield = $iter || nil;

        TMP_12.$$p = null;
        self.depth = depth;
        return Opal.find_super_dispatcher(self, 'initialize', TMP_12, null).apply(self, [$hash2(["success"], {"success": ($a = ($b = self).$lambda, $a.$$p = (TMP_11 = function(){var self = TMP_11.$$s || this, $a, $b, trace = nil;

        trace = $scope.get('Trace').$it(self).$reverse();
          trace.$pop();
          if ((($a = (($b = depth !== false && depth !== nil) ? $rb_le(depth, trace.$length()) : depth)) !== nil && (!$a.$$is_boolean || $a == true))) {
            trace.$shift($rb_minus(trace.$length(), depth))};
          return ($a = block).$call.apply($a, Opal.to_a(trace));}, TMP_11.$$s = self, TMP_11), $a).call($b)})]);
      }), nil) && 'initialize';
    })($scope.base, self);

    return (function($base, $super) {
      function $When(){};
      var self = $When = $klass($base, $super, 'When', $When);

      var def = self.$$proto, $scope = self.$$scope, TMP_13, TMP_15, TMP_17, TMP_19, TMP_23;

      def.wait = nil;
      Opal.defn(self, '$initialize', TMP_13 = function initialize(promises) {
        var $a, $b, TMP_14, self = this, $iter = TMP_13.$$p, $yield = $iter || nil;

        if (promises == null) {
          promises = []
        }
        TMP_13.$$p = null;
        Opal.find_super_dispatcher(self, 'initialize', TMP_13, null).apply(self, []);
        self.wait = [];
        return ($a = ($b = promises).$each, $a.$$p = (TMP_14 = function(promise){var self = TMP_14.$$s || this;
if (promise == null) promise = nil;
        return self.$wait(promise)}, TMP_14.$$s = self, TMP_14), $a).call($b);
      });

      Opal.defn(self, '$each', TMP_15 = function each() {
        var $a, $b, TMP_16, self = this, $iter = TMP_15.$$p, block = $iter || nil;

        TMP_15.$$p = null;
        if (block !== false && block !== nil) {
          } else {
          self.$raise($scope.get('ArgumentError'), "no block given")
        };
        return ($a = ($b = self).$then, $a.$$p = (TMP_16 = function(values){var self = TMP_16.$$s || this, $a, $b;
if (values == null) values = nil;
        return ($a = ($b = values).$each, $a.$$p = block.$to_proc(), $a).call($b)}, TMP_16.$$s = self, TMP_16), $a).call($b);
      });

      Opal.defn(self, '$collect', TMP_17 = function collect() {
        var $a, $b, TMP_18, self = this, $iter = TMP_17.$$p, block = $iter || nil;

        TMP_17.$$p = null;
        if (block !== false && block !== nil) {
          } else {
          self.$raise($scope.get('ArgumentError'), "no block given")
        };
        return ($a = ($b = self).$then, $a.$$p = (TMP_18 = function(values){var self = TMP_18.$$s || this, $a, $b;
if (values == null) values = nil;
        return $scope.get('When').$new(($a = ($b = values).$map, $a.$$p = block.$to_proc(), $a).call($b))}, TMP_18.$$s = self, TMP_18), $a).call($b);
      });

      Opal.defn(self, '$inject', TMP_19 = function inject() {
        var $a, $b, TMP_20, self = this, $rest_idx, $rest_len = arguments.length - 0, $iter = TMP_19.$$p, block = $iter || nil;

        var args = new Array($rest_len > 0 ? $rest_len : 0);
        if ($rest_len > 0) {
          for ($rest_idx = 0; $rest_idx < $rest_len; $rest_idx++) {
            args[$rest_idx] = arguments[$rest_idx + 0];
          }
        }
        TMP_19.$$p = null;
        return ($a = ($b = self).$then, $a.$$p = (TMP_20 = function(values){var self = TMP_20.$$s || this, $a, $b;
if (values == null) values = nil;
        return ($a = ($b = values).$reduce, $a.$$p = block.$to_proc(), $a).apply($b, Opal.to_a(args))}, TMP_20.$$s = self, TMP_20), $a).call($b);
      });

      Opal.alias(self, 'map', 'collect');

      Opal.alias(self, 'reduce', 'inject');

      Opal.defn(self, '$wait', function wait(promise) {
        var $a, $b, TMP_21, self = this;

        if ((($a = $scope.get('Promise')['$==='](promise)) !== nil && (!$a.$$is_boolean || $a == true))) {
          } else {
          promise = $scope.get('Promise').$value(promise)
        };
        if ((($a = promise['$act?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
          promise = promise.$then()};
        self.wait['$<<'](promise);
        ($a = ($b = promise).$always, $a.$$p = (TMP_21 = function(){var self = TMP_21.$$s || this, $a;
          if (self.next == null) self.next = nil;

        if ((($a = self.next['$any?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$try()
            } else {
            return nil
          }}, TMP_21.$$s = self, TMP_21), $a).call($b);
        return self;
      });

      Opal.alias(self, 'and', 'wait');

      Opal.defn(self, '$>>', TMP_23 = function () {
        var $a, $b, TMP_22, self = this, $iter = TMP_23.$$p, $yield = $iter || nil, $zuper = nil, $zuper_index = nil;

        TMP_23.$$p = null;
        $zuper = [];
        for($zuper_index = 0; $zuper_index < arguments.length; $zuper_index++) {
          $zuper[$zuper_index] = arguments[$zuper_index];
        }
        return ($a = ($b = Opal.find_super_dispatcher(self, '>>', TMP_23, $iter).apply(self, $zuper)).$tap, $a.$$p = (TMP_22 = function(){var self = TMP_22.$$s || this;

        return self.$try()}, TMP_22.$$s = self, TMP_22), $a).call($b);
      });

      return (Opal.defn(self, '$try', function () {
        var $a, $b, $c, $d, self = this, promise = nil;

        if ((($a = ($b = ($c = self.wait)['$all?'], $b.$$p = "realized?".$to_proc(), $b).call($c)) !== nil && (!$a.$$is_boolean || $a == true))) {
          if ((($a = promise = ($b = ($d = self.wait).$find, $b.$$p = "rejected?".$to_proc(), $b).call($d)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$reject(promise.$error())
            } else {
            return self.$resolve(($a = ($b = self.wait).$map, $a.$$p = "value".$to_proc(), $a).call($b))
          }
          } else {
          return nil
        };
      }), nil) && 'try';
    })($scope.base, self);
  })($scope.base, null)
};
